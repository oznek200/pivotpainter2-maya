
# PivotPainter2 for Maya — Algorithm Notes: X-Vector (`pp2_XVector.py`)

このドキュメントは、Pivot Painter 2 用 **X-Vector テクスチャ**（PNG/8bit RGBA）を書き出す `PP2XVectorExporter` の**何を・なぜ・どうやって**を整理した技術解説です。
目的は、Maya の **Transform 階層**から各ノードの **ローカル +X 軸（→ワールド空間）** を 1 ドット UV に焼き込み、UE の PP2 マテリアルで使用可能なベクトルテクスチャを生成することです。

---

## 1) 目的と入出力

### 目的

* 各 Transform の **ローカル +X 軸ベクトル**を **ワールド空間**へ変換し、**正規化**したうえで **0..1** にリマップして **PNG (RGBA8)** へ格納。
* A チャンネルには **階層深度**に応じた定数値（α）を埋め込み、シェーダ側の重み/減衰に利用可能にする。

### 入力（前提）

* ルート Transform（幹）を 1 つ選択。
* 各 Transform に mesh が 1 つぶら下がっている想定。
* **pp2\_uv** が無い場合は自動作成（カレント化し、その **map\[0]** から **1 ドット UV** を読む）。

### 出力

* `out_dir/base_name.png`
  **RGBA（8bit）**：

  * **R**：ワールド **X** 成分（`-1..1 → 0..1`）
  * **G**：ワールド **Z** 成分（`-1..1 → 0..1`）※G/B は Z/Y の順でスウィズル
  * **B**：ワールド **Y** 成分（`-1..1 → 0..1`）
  * **A**：深度 α（`{0:19/255, 1:7/255, 2:5.5/255, 3:5/255}`）

> **注意**：PNG 8bit のため、**精度が必要なら EXR(float)** を選ぶ実装に差し替えることを推奨。

---

## 2) 全体フロー

1. **選択チェック**：ルート Transform を確保（`_require_selection`）。
2. **階層列挙**：`_enum_tree(root)` で深さ優先 `(node, parentIdx, depth)` 配列を作成。
3. **UV 準備**：各 mesh に `pp2_uv` を用意し **current 化**（`_ensure_uv`）。
4. **UV グリッド化**：

   * 各ノードの `map[0]` の **(u, v)** を収集し、
     `cols = sorted(Uset)`, `rows = sorted(Vset, reverse=True)` で **列/行**を確定。
   * `row = v_idx[v]`, `col = u_idx[u]` で **1 ノード = 1 ピクセル**の位置を決定。
5. **X-Vector 取得**：

   * `cmds.xform(ws=True, m=True)` で **ワールド変換行列**を取り、
     **最初の 3 要素**（`m[0], m[1], m[2]`）から **ローカル +X のワールド方向**を抽出。
   * `om2.MVector(...).normalize()` で **正規化**。
6. **RGBA 書き込み**：

   * **R = vx.x, G = vx.z, B = vx.y** を `(-1..1 → 0..1)` にリマップ（`*0.5 + 0.5`）。
   * **A** は `DEPTH_ALPHA[depth]` をセット。
7. **PNG 保存**：`_save_png_rgba` で **0..1 → 0..255**、`uint8` へ量子化し保存。

---

## 3) UV の扱い（1ドット UV 前提）

* `pp2_uv` が無い場合、`_ensure_uv` で **create** し current 化。
  （※PivotPosition 実装と違い、こちらは**map1 のコピー**ではなく **空の pp2\_uv** を使う設計。既に 1 ドット UV が敷かれている想定）
* 各ノードの `map[0]` の (u, v) を読み取り、**Uset/Vset** を構築。
* **V は降順**で並べ、画像上の **上→下** に対応させる。

> **実運用では**：pp2\_uv の 1 ドット UV の自動敷設（行列状に割付）を別ユーティリティで行うと事故が減ります。

---

## 4) ローカル +X → ワールドの取り出し

```python
m = cmds.xform(tr, q=True, ws=True, m=True)  # 4x4 のフラット配列
vx = om2.MVector(m[0], m[1], m[2]).normalize()
```

* Maya の **行列レイアウト**に合わせ、**先頭 3 要素**が **ローカル +X** の **ワールド方向**を表す（回転・スケールを含む）。
* `.normalize()` で **単位ベクトル**にしてから **0..1** へリマップ。
* **チャンネルのスウィズル**：

  * **R = X**, **G = Z**, **B = Y**（UE 側マテリアルの想定に合わせるための順序）
  * ここは **シェーダ側の復元**と必ず一致させること。

---

## 5) 深度 α（A チャンネル）

```python
DEPTH_ALPHA = {0: 19/255.0, 1: 7/255.0, 2: 5.5/255.0, 3: 5/255.0}
```

* **階層の深さ**に応じた **固定 α 値**を埋め込み。
* 用途例：シェーダ内で**幹→枝→葉**へ向かうほど揺れや変形の重みを変える、あるいは LOD/重みづけのマスクとして利用。
* 深さが 3 を超える場合は `get(depth, 5/255.0)` でフォールバック。

> **改善案**：深度の最大値に合わせて **連続関数**にする、あるいは **別テクスチャ**で整数深度を持たせる方法も有効。

---

## 6) 量子化と PNG 8bit の注意

* `np.rint(clip(arr)*255).astype(uint8)` で **0..1 → 0..255** に量子化。
* **ベクトルテクスチャは符号付き情報（-1..1）** を持つため、量子化誤差の影響が出やすい。
* **高精度が必要**なプロジェクトでは、**EXR(float)** 出力へ差し替えると安定。

---

## 7) 実装メモ（関数ごとの要点）

* `_enum_tree(root)`：深さ優先 `(node, parentIdx, depth)` を列挙。**親インデックス**は PivotPosition と突き合わせ可能。
* `_ensure_uv(mesh)`：`pp2_uv` を **create & current** に。**既存 UV を壊さない**（非破壊）設計。
* `export()`：UV グリッド → ベクトル抽出 → 書き込み → PNG 保存 → inViewMessage。

---

## 8) UE 側との整合（最重要）

* **R/G/B の軸割り当て**（X/Z/Y）と **(-1..1→0..1) リマップ**は、**マテリアル側の復元式**と一致させること。
* PivotPosition 側の取り扱い（スウィズルや親インデックスの扱い）とも**整合**を取る。
* 可能なら **EXR 版 X-Vector** も用意し、プロジェクトに応じて切替できると堅牢。

---

## 9) よくある質問（FAQ）

* **Q. G と B が Z/Y の順なのはなぜ？**
  **A.** UE 側のシェーダや座標系整合の都合です。**X/Y/Z** の並びは**必ずマテリアル実装とペアで管理**してください。

* **Q. スケールを含む Transform でも大丈夫？**
  **A.** `.normalize()` で単位化しているため、**方向ベクトルとしては問題なし**。ただし**非均一スケール + 回転**の順序によっては期待と異なる場合があるため、可能ならリグ側で正規化を推奨。

* **Q. 8bit PNG で精度が足りないときは？**
  **A.** EXR(float32) 出力へ切替。あるいは **snorm** 的パッキング（`int16`/`RG16F` など）を検討。

---

## 10) 改良のヒント

* **UV 自動敷設**：pp2\_uv の 1 ドット UV を自動生成し、**行列状**に割り当てるユーティリティを同梱。
* **EXR 対応**：`_save_png_rgba` 相当を **OpenEXR** 実装に差し替え可能に。
* **深度 α の一般化**：深さに応じた連続関数 or 別テクスチャ化。
* **大量ノード最適化**：`xform` 呼び出しの回数削減、`maya.api.OpenMaya` のイテレーション最適化。

---

## 11) まとめ

* **X-Vector** は **「ローカル +X をワールドに投影した方向」** を **0..1** にパックしたテクスチャ。
* **1 ドット UV** に各ノードをマッピングし、**R=X, G=Z, B=Y, A=深度** として保存。
* **PNG 8bit** は手軽だが精度に限界があるため、プロジェクト要件次第で **EXR** を推奨。
* **UE の PP2 マテリアルと整合**するよう、チャンネル割り当て・座標系・深度 α の使い方を**必ずペアで設計**してください。

---

以上
