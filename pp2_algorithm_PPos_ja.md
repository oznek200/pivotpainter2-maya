
# PivotPainter2 for Maya — Algorithm Notes (`pp2_algorithm.md`)

このドキュメントは、`pp2_pivotposition.py (safe-UV & no-error)` の処理内容を、**何を・なぜ・どうやって**行っているかの観点で整理した技術解説です。
目的は **Pivot Painter 2 用の PivotPosition テクスチャ (EXR)** を、Maya の階層メッシュから安定して生成することです。

---

## 1) 目的と入出力

### 目的

* Transform 階層（幹→枝→葉…）を走査し、各ノードの**ワールド空間ピボット位置**を画像にエンコードする。
* 各ノードが属する **pp2 専用 UV（pp2\_uv）** 上の 1 画素に、対応する値を**RGBA**で格納する。

### 入力（前提）

* Maya シーン内の **Transform 階層のルート（幹）を 1つ選択**。
* 各 Transform に **1つの mesh シェイプ**がぶら下がっている構成を想定。
* **pp2\_uv** という UV セットを使用（存在しない場合は `map1` から複製して作成）。

### 出力

* `out_dir/base_name.exr`
  4ch（RGBA, float32）の **OpenEXR** 画像。各画素＝各 Transform に対応。

---

## 2) 全体フロー

1. **選択チェック**：幹 Transform が選択されているかを確認（`_require_selection`）。
2. **階層列挙**：深さ優先で `(node, parent_index, depth)` の配列を生成（`_enum_tree`）。
3. **UV セットの存在確認**：mesh ごとに `pp2_uv` がなければ `map1` から複製（`_ensure_uv`）。
4. **UV サンプリング**：

   * 一時的に **current UV set を `pp2_uv` に切替**え、`map[0]` の **(u, v)** を取得。
   * 元の current に戻す（safe／no-error ポイント）。
5. **ピボット取得**：各ノードの **ワールド空間ピボット**（`xform -ws -rp`）を `MPoint` で保持。
6. **UV グリッド確定**：

   * 収集した **U の集合**（列）と **V の集合**（行）をソートし、**グリッド座標 (row, col)** へ変換。
   * ※V は **降順**（上から下へ行を割り当てるため）。
7. **テクスチャ配列生成**：`(rows, cols, 4)` の float32 配列をゼロ初期化。
8. **RGBA 書き込み**：各ノードの (row, col) に以下を格納：

   * **R**：`(piv_w[node] - piv_w[root]).x`（ルートからの相対オフセット X）
   * **G**：`piv_w[node].z`（ワールド Z）
   * **B**：`(piv_w[node] - piv_w[root]).y`（ルートからの相対オフセット Y）
   * **A**：親の **列挙インデックス**を `_pack_parent()` で **float 埋め込み**
9. **EXR 書き出し**（`_save_exr`）：RGBA float で OpenEXR へ出力。
10. **inViewMessage** で完了通知。

> 注：チャンネルの割当（R=Δx, G=z, B=Δy）には**意図的なスウィズル**が入っています。
> シェーダ側（UE の PP2 マテリアル）での取り出しと整合することが前提です。
> 必要に応じて G/B の扱いを設計書と一致させてください。

---

## 3) UV の扱い（安全設計）

* **既存の UV（map1/set1 等）を変更しない**ことが最重要。
  → 書き換えは行わず、`pp2_uv` を **map1 から複製**して使用。
* `polyEditUV -uvSet` によるエラー回避のため、**現在の UV セットを退避**し、
  `pp2_uv` を **一時的に current** にして `map[0]` をサンプリング → **元に戻す**。

これにより、既存のアセットに影響を与えず **安全に 1ドット UV から U/V を読む**ことができます。

---

## 4) UV → 画像グリッド変換

* 各 mesh（各 Transform 子）の `pp2_uv` 上の **map\[0]** の **(u, v)** を収集。
* 集合 **Uset**（列）・**Vset**（行）を作り、ソートして **列/行の順序**を固定化。

  * 列：`cols = sorted(Uset)`
  * 行：`rows = sorted(Vset, reverse=True)`  ← 画像の上から下へ
* ノードごとのグリッド位置：
  `row = v_idx[v]; col = u_idx[u]`
  `index = row * numCols + col`

**ポイント**：

* 1ノード＝1ピクセル（1ドット）という前提で、PP2 テクスチャの**画素配置**を安定化。
* UV の **小数丸め（round(u, 6)）** で浮動小数のブレを抑制し、安定した集合化を実現。

---

## 5) ピボットのエンコード（RGBA）

**ワールドピボット**は `xform -ws -rp` で取得。
`root`（幹）との差分 `dv = piv_w[node] - piv_w[root]` を用い、以下のように格納：

* **R**：`dv.x`
* **G**：`piv_w[node].z`
* **B**：`dv.y`
* **A**：`_pack_parent(parent_index)` の戻り値

> なぜ **相対（Δ）** と **絶対（Z）** を混在させるのか？
> → 本実装のマテリアル設計に基づく**座標系の都合**（ジンバル・軸取りの都合や、親子変換の簡略化）が想定されます。
> ここはプロジェクトの PP2 シェーダ仕様と必ず整合を取ってください。

---

## 6) 親インデックスのパック（Aチャンネル）

```python
@staticmethod
def _pack_parent(idx: int) -> float:
    return (1024 + idx) / float(2**24)
```

* **親の列挙インデックス**（root の場合は `-1` を持ち得るが、呼び出し側で `get(pidx, 0)` を適用）を
  **24bit スケール**で **浮動小数（0〜1）** に圧縮。
* `+1024` のオフセットは、**極小値や 0 付近を避ける**ためのガード（UE 側の精度・フィルタで埋もれないようにする工夫）として使われています。
  ※プロジェクト要件に応じて **バイアス値**や **スケール**は見直し可能。
* シェーダ側では、**A を 0–1 の float として受け取り、逆変換**して親インデックスを取得します。

---

## 7) EXR 出力

* **RGBA = float32** で OpenEXR に書き出し。
* ヘッダの `channels` に **RGBA** を定義し、各チャンネルの `tobytes()` を直接書き込むため**高速**かつ**劣化なし**。

```python
hdr["channels"] = {c: Imath.Channel(Imath.PixelType(Imath.PixelType.FLOAT)) for c in "RGBA"}
out.writePixels({c: arr[..., i].tobytes() for i, c in enumerate("RGBA")})
```

---

## 8) 実装詳細（関数メモ）

* `_module_dir` / `site.addsitedir` / `ext_site`
  → 3rd-party（OpenEXR, NumPy など）を **明示パス**から読み込めるようにする補助。
* `_enum_tree(root)`
  → **深さ優先**で `(node, parentIndex, depth)` を `out` にプッシュ。
  `parentIndex` は **out 配列のインデックス**で参照しやすい。
* `_ensure_uv(mesh)`
  → `pp2_uv` が無い場合、`map1` から **コピー**して作成（破壊的変更を避ける）。
* `export()`
  → 上記の一連の流れを実行し、最後に `inViewMessage` でパスを通知。

---

## 9) 設計の要点（安全・安定・実運用）

* **安全性**：既存 UV を壊さない（`pp2_uv` のみ使用）。current UV を**退避→復元**。
* **安定性**：`round(u, 6)` で U/V 集合化のブレを抑制。
* **可用性**：mesh ごとに `pp2_uv` が無ければ自動生成。
* **移植性**：EXR の float32 により UE 側での精度確保が容易。

---

## 10) よくある質問（FAQ）

* **Q. G と B のチャンネルが “Z と ΔY” でスウィズルされている理由は？**
  **A.** 本実装の PP2 マテリアルの設計都合です。UE 側の復元ロジックに合わせています。必要に応じて**チャンネル割り当てを要件に合わせて変更**してください。

* **Q. 親インデックスのパック方法は固定ですか？**
  **A.** いいえ。A チャンネルの精度やフィルタ耐性、必要とする最大ノード数に応じて、**バイアス（1024）や分解能（2^24）** を見直せます。UE側と**対**で設計してください。

* **Q. 複数 mesh／1 Transform のケースは？**
  **A.** 現実装は「1 Transform に 1 mesh」を前提にしています。必要なら `listRelatives(..., type="mesh")` の複数対応・代表面の決定などを追加してください。

---

## 11) 改良のヒント

* **pp2\_uv の自動生成**をより厳密に（1ドット UV の自動敷設・重複検出・ソート安定化）。
* **座標系**（右手/左手）の差異や Z-up/Y-up の違いに対する抽象化。
* **親子インデックスのパック**をテクスチャ 2 枚目へ分離（Integer 16bit/EXR など）して整数で扱う方式も検討可。
* **大規模階層**（数千ノード）向けの **バッチ化・NumPy 一括演算**。

---

## 12) UE 側との整合（最重要）

* 本 EXR 仕様と **UE の PP2 マテリアル**は**必ず対で設計**してください。
* チャンネル割り当て（R/G/B）・親インデックスの復号（A）・単位系・スケールは、**マテリアル側での復元式**と一致している必要があります。

---

以上。
